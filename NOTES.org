* Compiler Passes
** Collect all data types
*** Build layout(s) for datapath buses etc. including type tag
*** Build block rams and garbage collectors for each type
** Collect all symbols
*** Build symbol table
** ...
** Create thing(s) above module-specification
*** type symbol -> size
** Create module-specification
* Ideas and Questions
** Can tighten up the sub-FSM calls?
** Easy to share states by hand, but how to automate?
** How will lazy evaluation fit in?
** Can operations share ports? (currently they will if they name them the same)
** Either check uniqueness of operation/state names or use gensyms or something
** If there's only one operation, we don't need op selector
** If the only operation is combinational, we don't need start/busy signals
** Can we elide unused operations from sub-FSM?
** Support for dispatching multiple sub-module operations and awaiting all of them
** More complicated sub-module dispatch might need FIFOs for args
** Optimization to fuse states with no dependencies (e.g. the second state of a sub-module operation can fuse with the next state)
* Tasks
** TODO design final nanopass language for generating verilog modules
*** DONE module name
*** DONE ports
*** DONE operations
**** DONE pass a list of symbols
**** DONE use length to generate operation input
**** DONE use list to generate localparams
**** DONE maybe operations should declare their own input/outputs? yes.
*** DONE states
**** DONE state should have: label, assigns, next state logic
**** DONE maybe this is wrapped as sub state machine per operation (see above)? yes.
*** DONE registers
*** TODO instantiations
*** DONE next state logic
*** DONE output/register assignments
**** Simple register to register
**** Register to/from memory
**** Allowed combinatorial operators
*** DONE parameters
**** Should this just be bookkeeping we just do? It's only being done for word size... yes.
** TODO write out pair and environment modules in the new language
