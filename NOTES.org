* Compiler Passes
** Collect all data types
*** Build layout(s) for datapath buses etc. including type tag
*** Build block rams and garbage collectors for each type
** Collect all symbols
*** Build symbol table
** ...
** Create thing(s) above module-specification
*** type symbol -> size
** Create module-specification
* Ideas and Questions
** Can tighten up the sub-FSM calls?
** Easy to share states by hand, but how to automate?
** How to remove hard-coded bitwidth in literals? (parameters might just be done in intermediate lang)
** How will lazy evaluation fit in?
* Tasks
** TODO design final nanopass language for generating verilog modules
*** DONE module name
*** DONE ports
*** DONE operations
**** DONE pass a list of symbols
**** DONE use length to generate operation input
**** DONE use list to generate localparams
**** TODO maybe operations should declare their own input/outputs?
*** TODO states
**** TODO state should have: label, assigns, next state logic
**** TODO maybe this is wrapped as sub state machine per operation (see above)?
*** TODO registers
*** TODO instantiations
*** TODO next state logic
*** TODO output/register assignments
**** Simple register to register
**** Register to/from memory
**** Allowed combinatorial operators
*** TODO parameters
**** Should this just be bookkeeping we just do? It's only being done for word size...
** TODO write out pair and environment modules in the new language
